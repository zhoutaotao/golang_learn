/**
* @Author:zhoutao
* @Date:2021/1/2 上午11:23
* @Desc:
 */

package escape

// 逃逸分析对性能的影响:从性能的角度出发，从栈上分配内存和在堆上分配内存，性能差异是非常大的
// 在函数中申请一个对象，如果分配在栈中，函数执行结束后会自动回收，如果分配在堆中，则在函数结束后某个时间点进行垃圾回收

// 在栈上分配和回收内存的开销很低，只要2个CPU指令：PUSH和POP，一个是数据push到栈空间以完成分配，pop则是释放空间，
// 也就是说在栈上分配内存，消耗的仅仅是将数据拷贝到内存的时间，而内存的I/O通常能够达到30GB/s，因此在栈上分配内存效率是非常高的

// 在对上分配内存，很大的额外开销则是垃圾回收。Go语言使用的是标记清除算法，并且在此基础上使用了三色标记法和写屏障技术，提高效率

//go的编译器怎么知道哪个变量需要分配在栈上，哈哈是堆上？编译器决定内存分配位置的方式，就称之为逃逸分析。逃逸分析由编译器决定，作用于编译阶段

// 传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。
// 传指针可以减少至的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收的负担。
// 在对象频繁创建和删除的场景中，传递指针会导致GC开销可能会严重影响性能

// 一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。
// 对于只读的占用内存较小的结构体，传值能获得更好的性能
